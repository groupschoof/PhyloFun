library(XML)
library(utils)
library(RCurl)
library(parallel)

uniprotkb.url <- function( accession ) {
  # Returns valid URL to access Uniprot's RESTful Web-Service to download
  # data about the Protein as referenced by the argument 'accession'.
  # Note, that the accession is URL encoded before being pasted into the
  # Uniprot URL template.
  #
  # Args:
  #  accession : The Protein's Uniprot accession.
  #
  # Returns: The Uniprot URL for the argument accession.
  #   
  paste(
    'http://www.ebi.ac.uk/Tools/dbfetch/dbfetch/uniprotkb/',
    URLencode( accession ),
    '/xml',
    sep=''
    )
}

extract.annotations <- function(doc, type) {
  # Parses XLM document and extracts the 'id' attributes of all
  # 'dbReference' tags where the 'type' attribute is set to the provided
  # argument.
  #
  # Args:
  #  doc : Downlaoded and parsed XMl document as returned by 'xmlInternalTreeParse'
  #  type : The type of 'dbReference' tags to extract. I.e. 'InterPro'.
  #
  # Returns: A character vector of all 'id' attributes of the
  # 'dbReference' tags having their 'type' attribute set to this
  # functions argument 'type'. 
  #   
  ns <- c(xmlns="http://uniprot.org/uniprot");
  ndst <- getNodeSet(doc,
    paste("//xmlns:dbReference[@type='",type,"']",sep=""),
    namespaces=ns
    );
  vapply(ndst, xmlGetAttr, vector(mode='character', length=1), 'id');
}

retrieve.annotations <- function(url, annotations=c('GO','InterPro','Pfam')) {
  # Downloads and parses XMl representation of protein as available using
  # the argument 'url' to access Uniprot's RESTful web service. The
  # domain annotations encoded in the downloaded document is then
  # extracted and returned as a list. The type of domains extracted is
  # defined by the argument 'annotations'.
  #
  # Args:
  #   url : Unique access to the Uniprot web service for the contained
  #         accession. As returned by the function 'uniprotkb.url'.
  #   annotations : Type of annotations to extract from the downloaded
  #                 document.
  #
  # Returns: list with keys as in argument annotations and values vectors
  # containing the annotated domain IDs of the corresponding types.
  # Exmpl:
  # $GO
  #  [1] "GO:0005737" "GO:0005634" "GO:0005524" "GO:0008026" "GO:0003725"
  # 
  # $InterPro
  # [1] "IPR005034" "IPR011545" "IPR001159" "IPR014001" "IPR001650" "IPR003100"
  # 
  # $Pfam
  # [1] "PF00270" "PF03368" "PF00271" "PF02170" "PF00636"
  #   
  doc <- try( xmlInternalTreeParse( getURL(url) ), silent=T );
  sapply(annotations,
    function(type) {
      setNames(list(
          if(! identical(class(doc),"try-error")) {
            extract.annotations(doc,type)
          } else {
            NA
          }), type)
    },
    USE.NAMES=F)
}

retrieveSequence <- function( doc, noverbose=T ) {
  # Parses the XML Uniprot document 'doc' and returns the content of the
  # contained amino acid sequence.
  #
  # Args:
  #  doc : The document downloaded from Uniprot using the URL as generated by
  #        function 'uniprotkb.url'.
  #  noverbose : The XMl parsing is executed within a try expression,
  #              should that be run in silent-mode?
  #
  # Returns: The content of the contained '<sequence>...</sequence>' tag.
  #   
  ns <- c(xmlns="http://uniprot.org/uniprot");
  try(
    gsub("\\s", "",
      xmlValue( getNodeSet( doc, "//xmlns:entry/xmlns:sequence", ns )[[1]] )
      ),
    silent=noverbose)
}

retrieve.annotations.parallel <- function(accessions, ...) {
  # Method invokes the function retrieve.annotations for each provided
  # accession in parallel. Resulting lists of annotated domain ids of the
  # various types are merged into a matrix. The annotated domain types
  # will be the matrix's row names and column names will be the argument
  # 'accessions'. 
  #
  # Args:
  #  accessions : Uniprot accessions to retrieve anntotated domains for.
  #  ...        : Additional provided arguments are passed on to the function
  #               'retrieve.annotations' and can be used to narrow the returned
  #               matrix's rows to less than the default domain types 'InterPro', 'GO'
  #               and 'Pfam'. 
  #
  # Returns: A matric with row names the function annotation types and
  # column names the accessions they were retrieved for from Uniprot.
  #   
  do.call('rbind',
    mclapply(accessions,
    function(acc) {
      acc.annos <- retrieve.annotations(uniprotkb.url(acc),...)
      matrix(acc.annos, nrow=1, dimnames=list(c(acc),names(acc.annos)))
    },
    mc.preschedule=F, mc.cores=50)
  )
}

retrieve.annotations.parallel.t <- function(accessions, ...) {
  # Method invokes the function retrieve.annotations for each provided
  # accession in parallel. Resulting lists of annotated domain ids of the
  # various types are merged into a matrix. The annotated domain types
  # will be the matrix's column names and row names will be the argument
  # 'accessions'. 
  # NOTE: This method returns the transposed matrix as generated by function
  # 'retrieve.annotations.parallel'.
  #
  # Args:
  #  accessions : Uniprot accessions to retrieve anntotated domains for.
  #  ...        : Additional provided arguments are passed on to the function
  #               'retrieve.annotations' and can be used to narrow the returned
  #               matrix's rows to less than the default domain types 'InterPro', 'GO'
  #               and 'Pfam'. 
  #
  # Returns: A matric with column names the function annotation types and
  # row names the accessions they were retrieved for from Uniprot.
  #   
  do.call('cbind',
    mclapply(accessions,
    function(acc) {
      acc.annos <- retrieve.annotations(uniprotkb.url(acc),...)
      matrix(acc.annos, nrow=length(acc.annos),
        dimnames=list(names(acc.annos),c(acc)))
    },
    mc.preschedule=F, mc.cores=50)
  )
}

uniq.annotations <- function(annotation.matrix, type) {
  sort(
    unique(do.call('c', (annotation.matrix[, type]))),
    na.last=F
    )
}
