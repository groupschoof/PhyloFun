library(XML)
library(utils)
library(RCurl)
library(parallel)
library(biomaRt)

uniprotkb.url <- function( accession ) {
  # Returns valid URL to access Uniprot's RESTful Web-Service to download
  # data about the Protein as referenced by the argument 'accession'.
  # Note, that the accession is URL encoded before being pasted into the
  # Uniprot URL template.
  #
  # Args:
  #  accession : The Protein's Uniprot accession.
  #
  # Returns: The Uniprot URL for the argument accession.
  #   
  paste(
    'http://www.ebi.ac.uk/Tools/dbfetch/dbfetch/uniprotkb/',
    URLencode( accession ),
    '/xml',
    sep=''
    )
}

extract.annotations <- function(doc, type) {
  # Parses XLM document and extracts the 'id' attributes of all
  # 'dbReference' tags where the 'type' attribute is set to the provided
  # argument.
  #
  # Args:
  #  doc : Downlaoded and parsed XMl document as returned by 'xmlInternalTreeParse'
  #  type : The type of 'dbReference' tags to extract. I.e. 'InterPro'.
  #
  # Returns: A character vector of all 'id' attributes of the
  # 'dbReference' tags having their 'type' attribute set to this
  # functions argument 'type'. 
  #   
  ns <- c(xmlns="http://uniprot.org/uniprot");
  ndst <- getNodeSet(doc,
    paste("//xmlns:dbReference[@type='",type,"']",sep=""),
    namespaces=ns
    );
  vapply(ndst, xmlGetAttr, vector(mode='character', length=1), 'id');
}

retrieve.annotations <- function(url, annotations=c('GO','InterPro','Pfam')) {
  # Downloads and parses XMl representation of protein as available using
  # the argument 'url' to access Uniprot's RESTful web service. The
  # domain annotations encoded in the downloaded document is then
  # extracted and returned as a list. The type of domains extracted is
  # defined by the argument 'annotations'.
  #
  # Args:
  #   url : Unique access to the Uniprot web service for the contained
  #         accession. As returned by the function 'uniprotkb.url'.
  #   annotations : Type of annotations to extract from the downloaded
  #                 document.
  #
  # Returns: list with keys as in argument annotations and values vectors
  # containing the annotated domain IDs of the corresponding types.
  # Exmpl:
  # $GO
  # [1] "GO:0005737" "GO:0005634" "GO:0005524" "GO:0008026" "GO:0003725"
  # 
  # $InterPro
  # [1] "IPR005034" "IPR011545" "IPR001159" "IPR014001" "IPR001650" "IPR003100"
  # 
  # $Pfam
  # [1] "PF00270" "PF03368" "PF00271" "PF02170" "PF00636"
  #   
  doc <- try( xmlInternalTreeParse( getURL(url) ), silent=T );
  sapply(annotations,
    function(type) {
      setNames(list(
          if(! identical(class(doc),"try-error")) {
            extract.annotations(doc,type)
          } else {
            NA
          }), type)
    },
    USE.NAMES=F)
}

retrieve.annotations.parallel.t <- function(accessions, ...) {
  # Method invokes the function retrieve.annotations for each provided
  # accession in parallel. Resulting lists of annotated domain ids of the
  # various types are merged into a matrix. The annotated domain types
  # will be the matrix's row names and column names will be the argument
  # 'accessions'. 
  #
  # Args:
  #  accessions : Uniprot accessions to retrieve anntotated domains for.
  #  ...        : Additional provided arguments are passed on to the function
  #               'retrieve.annotations' and can be used to narrow the returned
  #               matrix's rows to less than the default domain types 'InterPro', 'GO'
  #               and 'Pfam'. 
  #
  # Returns: A matric with row names the function annotation types and
  # column names the accessions they were retrieved for from Uniprot.
  #   
  do.call('rbind',
    mclapply(accessions,
    function(acc) {
      acc.annos <- retrieve.annotations(uniprotkb.url(acc),...)
      matrix(acc.annos, nrow=1, dimnames=list(c(acc),names(acc.annos)))
    },
    mc.preschedule=F, mc.cores=50)
  )
}

retrieve.annotations.parallel <- function(accessions, ...) {
  # Method invokes the function retrieve.annotations for each provided
  # accession in parallel. Resulting lists of annotated domain ids of the
  # various types are merged into a matrix. The annotated domain types
  # will be the matrix's column names and row names will be the argument
  # 'accessions'. 
  # NOTE: This method returns the transposed matrix as generated by function
  # 'retrieve.annotations.parallel'.
  #
  # Args:
  #  accessions : Uniprot accessions to retrieve anntotated domains for.
  #  ...        : Additional provided arguments are passed on to the function
  #               'retrieve.annotations' and can be used to narrow the returned
  #               matrix's rows to less than the default domain types 'InterPro', 'GO'
  #               and 'Pfam'. 
  #
  # Returns: A matric with column names the function annotation types and
  # row names the accessions they were retrieved for from Uniprot.
  #   
  do.call('cbind',
    mclapply(accessions,
    function(acc) {
      acc.annos <- retrieve.annotations(uniprotkb.url(acc),...)
      matrix(acc.annos, nrow=length(acc.annos),
        dimnames=list(names(acc.annos),c(acc)))
    },
    mc.preschedule=F, mc.cores=50)
  )
}

uniq.annotations <- function(annotation.matrix, type) {
  sort(
    unique(do.call('c', (annotation.matrix[type,]))),
    na.last=F
    )
}

retrieveAnnotationsBiomart <- function( accs,
    uni.mart=useDataset("uniprot",mart=useMart("unimart"))
  ) {
  # Uses library biomaRt to retrieve InterPro and Gene Ontology annotations for
  # the Proteins referenced by their accessions in argument 'accs'. Results are
  # returned as a matrix where the rows are the Protein accessions and the
  # columns 'InterPro' and 'GO'. NOTE: This function cannot retrieve Pfam
  # annotations.
  #
  # Args:
  #  accs       : The accessions of the proteins to retrieve annotations for.
  #  uni.mart   : The biomaRt mart object to use.
  #
  # Returns: A matrix with all InterPro and GO annotations for the query
  # proteins. Columns are the protein accessions and rows 'InterPro' and 'GO'.
  #   
  annos <- getBM( c("accession", "interpro_id", "go_id"),
    filters=c("accession"), values=accs, mart=uni.mart )
  do.call( 'cbind',
    lapply( accs, function(a) {
      matrix(
        list( 
          'InterPro'=unique( annos[ annos["accession"] == a, "interpro_id" ] ),
          'GO'=unique( annos[ annos["accession"] == a, "go_id" ] )
        ),
        nrow=2, ncol=1,
        dimnames=list( c('InterPro', 'GO'), a )
      )
    })
  )
}

downloadUniprotDocuments <- function( uniprot.uris ) {
  # Downloads the documents from the RESTful Uniprot web service.
  #
  # Args:
  #  uniprot.uris : A vector or list of uniprot URLs
  #
  # Returns: Returns a named character vector of the downloaded XML documents.
  # Names are the 'uniprot.uris'.
  getURL( uniprot.uris )
}

retrieveSequence <- function( doc ) {
  # Parses the XML Uniprot document 'doc' and returns the content of the
  # contained amino acid sequence.
  #
  # Args:
  #  doc : The document downloaded from Uniprot using the URL as generated by
  #        function 'uniprotkb.url'.
  #
  # Returns: The content of the contained '<sequence>...</sequence>' tag.
  #   
  ns <- c(xmlns="http://uniprot.org/uniprot");
  gsub("\\s", "",
    xmlValue(
      getNodeSet(
        xmlInternalTreeParse(doc),
        "//xmlns:entry/xmlns:sequence",
        ns
      )[[1]]
    )
  )
}

retrieveSequences <- function( downloaded.uniprot.docs,
  max.retries=10, noverbose=F ) {
  # Parses each downloaded argument Uniprot document and extracts the content
  # of the '<sequence>' tag. If an error occurs doing so, re-tries downloading
  # and parsing the document, after sleeping a random amount of time out of
  # 1:90 seconds.
  #
  # Args:
  #  downloaded.uniprot.docs : The documents downloaded from Uniprot's RESTful
  #                            web service. 
  #  max.retries : The maximum number of times another download is attempted.
  #  noverbose : switch indicating wether to print out errors
  #
  # Returns: A named vector of extracted sequences or error messages.
  #   
  seqs <- sapply( downloaded.uniprot.docs, function( doc ) {
      try( retrieveSequence( doc ), silent=noverbose )
    })
  err.uris <- names( seqs[ class(seqs[]) == 'try-error' ] )
  if ( length(err.uris) > 0 && max.retries > 0 ) {
    Sys.sleep( sample(1:90, 1) )
    print( paste( "Retry number", as.character( 11 - max.retries) ) )
    seqs <<- c(
      seqs[ class(seqs[]) != 'try-error' ],
      retrieveSequences( downloadUniprotDocuments( err.uris ),
        (max.retries - 1) )
    )
  }
  # Return
  seqs
}
