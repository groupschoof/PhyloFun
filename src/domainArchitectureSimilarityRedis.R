initializeDomainWeights <- function( domain.weights.table ) {
  # Iterates over all rows of argument domain.weights.table, and stores in the
  # current redis server domain.weights.table[[ current.row, 1 ]].
  #
  # Args:
  #  domain.weights.table : A single column table of the domain weights, with
  #                         rownames being the domain IDs. 
  #
  # Returns: NULL
  #   
  lapply( rownames( domain.weights.table ), function( domain.id ) {
    redisSet( domain.id, domain.weights.table[[ domain.id, 1 ]] )
  })
  NULL
}

initializeDomainAnnotations <- function( domain.annotations,
  annotation.type = "InterPro" ) {
  # Each protein's set of annotated domains is stored as a Redis Set. Key is
  # the protein's accession and value the set of domain IDs of the argument
  # type 'annotation.type'.
  #
  # Args:
  #  domain.annotations : The table of domain annotations as generated by
  #                       function 'retrieveAnnotationsBiomart'.
  #  annotation.type : The row of argument 'domain.annotations' to read out.
  #
  # Returns: NULL
  #   
  lapply( colnames( domain.annotations ), function( protein.accession ) {
    prot.dom.annos <- domain.annotations[[ annotation.type, protein.accession ]]
    for( domain.id in prot.dom.annos ) {
      redisSAdd( protein.accession,
        charToRaw( as.character( domain.id ) )
      )
    }
  })
  NULL
}

pairwiseVectorSpaceModel <- function( protein.accession.a,
  protein.accession.b ) {
  # Returns the _unsorted_ set union of the domain annotations for both
  # argument proteins. Retrieves the two annotation sets from the current redis
  # connection. See function 'initializeDomainAnnotations' on how to initialize
  # this.
  #
  # Args:
  #  protein.accession.a : Accession of first protein
  #  protein.accession.b : Accession of second protein
  #
  # Returns: The set _unsorted_ set union of the two argument protein domain
  # annotation sets.
  #   
  redisSUnion( protein.accession.a, protein.accession.b )
}

generateDomainArchitectureSpaceVectorRedis <- function( protein.accession,
  vector.space.model ) {
  # Constructs a numeric vector where each element 'i' is either the domain
  # weight of the ith domain in the argument 'vector.space.model' or 0.0 if the
  # argument protein is not annotated with domain i. Note: Domains missing a
  # domain weight always will have a domain weight of 0.0!
  #
  # Args:
  #  protein.accession : The accession of the protein to generate the domain
  #                      architecture space vector for.
  #  vector.space.model : The set of domain IDs the vector space is composed
  #                       of.
  #
  # Returns: The numeric vector with the retrieved domain weights or 0.0, if
  # the argument vector is not annotated with domain i.
  #   
  as.numeric(
    lapply( vector.space.model, function( domain.id ) {
      dom.weight <- redisGet( domain.id )
      if( redisSIsMember( protein.accession, domain.id ) &&
          ! is.null(dom.weight) 
        ) {
        dom.weight
      } else {
        0.0
      }
    })
  )
}

pairwiseDASDistanceKey <- function( protein.accession.a,
  protein.accession.b ) {
  # Generates unique key to store the pairwise DAS distance under.
  #
  # Args:
  #  protein.accession.a : Accession of first protein.
  #  protein.accession.b : Accession of second protein.
  #
  # Returns: Alphabetically sorted arguments separated by underscore.
  #   
  paste.funk <- function( ... ) paste( ..., sep="_" ) 
  do.call( 'paste.funk',
    as.list( 
      sort( c(protein.accession.a, protein.accession.b) )
    )
  )
}

pairwiseDomainArchitectureDistanceRedis <- function( protein.accession.a,
  protein.accession.b, save.result=TRUE ) {
  # Computes the pairwise distance in the Domain Architecture Space (DAS) for
  # the two argument proteins. Retrieves required values from current redis
  # connection.
  #
  # Args:
  #  protein.accession.a : Accession of first protein.
  #  protein.accession.b : Accession of second protein.
  #  save.result : Store the computed distance in the DAS in the current redis
  #                connection using result of function 'pairwiseDASDistanceKey(
  #                protein.accession.a, protein.accession.b )'.
  #
  # Returns: The distance in DAS as computed by function
  # 'pairwiseDomainArchitectureDistance'.
  #   
  vsm <- pairwiseVectorSpaceModel( protein.accession.a, protein.accession.b )
  das.a <- generateDomainArchitectureSpaceVectorRedis( protein.accession.a, vsm )
  das.b <- generateDomainArchitectureSpaceVectorRedis( protein.accession.b, vsm )
  # compute 1.0 minus the cosine of the angle between the two vectors:
  das.dist <- pairwiseDomainArchitectureDistance( das.a, das.b )
  # Save result in redis, if requested:
  if( save.result ) {
    redisSet( 
      pairwiseDASDistanceKey( protein.accession.a, protein.accession.b ),
      das.dist
    )
  }
  # return
  das.dist
}
