library(XML)
library(utils)
library(RCurl)
library(parallel)
library(biomaRt)
library(stringr)

uniprotkb.url <- function( accession, frmt='xml' ) {
  # Returns valid URL to access Uniprot's RESTful Web-Service to download
  # data about the Protein as referenced by the argument 'accession'.
  # Note, that the accession is URL encoded before being pasted into the
  # Uniprot URL template.
  #
  # Args:
  #  accession : The Protein's Uniprot accession.
  #  frmt      : The format of the downloaded Uniprot Entry. Default is 'xml'.
  #
  # Returns: The Uniprot URL for the argument accession.
  #   
  paste(
    'http://www.ebi.ac.uk/Tools/dbfetch/dbfetch/uniprotkb/',
    URLencode( accession ),
    '/', frmt, sep=''
  )
}

extract.annotations <- function(doc, type) {
  # Parses XLM document and extracts the 'id' attributes of all
  # 'dbReference' tags where the 'type' attribute is set to the provided
  # argument.
  #
  # Args:
  #  doc : Downlaoded and parsed XMl document as returned by 'xmlInternalTreeParse'
  #  type : The type of 'dbReference' tags to extract. I.e. 'InterPro'.
  #
  # Returns: A character vector of all 'id' attributes of the
  # 'dbReference' tags having their 'type' attribute set to this
  # functions argument 'type'. 
  #   
  ns <- c( xmlns="http://uniprot.org/uniprot" )
  ndst <- getNodeSet( doc,
    paste( "//xmlns:dbReference[@type='", type, "']", sep="" ),
    namespaces=ns
  )
  vapply( ndst, xmlGetAttr, vector( mode='character', length=1 ), 'id' )
}

retrieve.annotations <- function(url, annotations=c('GO','InterPro','Pfam')) {
  # Downloads and parses XMl representation of protein as available using
  # the argument 'url' to access Uniprot's RESTful web service. The
  # domain annotations encoded in the downloaded document is then
  # extracted and returned as a list. The type of domains extracted is
  # defined by the argument 'annotations'.
  #
  # Args:
  #   url : Unique access to the Uniprot web service for the contained
  #         accession. As returned by the function 'uniprotkb.url'.
  #   annotations : Type of annotations to extract from the downloaded
  #                 document.
  #
  # Returns: list with keys as in argument annotations and values vectors
  # containing the annotated domain IDs of the corresponding types.
  # Exmpl:
  # $GO
  # [1] "GO:0005737" "GO:0005634" "GO:0005524" "GO:0008026" "GO:0003725"
  # 
  # $InterPro
  # [1] "IPR005034" "IPR011545" "IPR001159" "IPR014001" "IPR001650" "IPR003100"
  # 
  # $Pfam
  # [1] "PF00270" "PF03368" "PF00271" "PF02170" "PF00636"
  #   
  doc <- try( xmlInternalTreeParse( getURL(url) ), silent=T );
  sapply(annotations,
    function(type) {
      setNames(list(
          if(! identical(class(doc),"try-error")) {
            extract.annotations(doc,type)
          } else {
            NA
          }), type)
    },
    USE.NAMES=F)
}

retrieve.annotations.parallel.t <- function(accessions, ...) {
  # Method invokes the function retrieve.annotations for each provided
  # accession in parallel. Resulting lists of annotated domain ids of the
  # various types are merged into a matrix. The annotated domain types
  # will be the matrix's row names and column names will be the argument
  # 'accessions'. 
  #
  # Args:
  #  accessions : Uniprot accessions to retrieve anntotated domains for.
  #  ...        : Additional provided arguments are passed on to the function
  #               'retrieve.annotations' and can be used to narrow the returned
  #               matrix's rows to less than the default domain types 'InterPro', 'GO'
  #               and 'Pfam'. 
  #
  # Returns: A matric with row names the function annotation types and
  # column names the accessions they were retrieved for from Uniprot.
  #   
  do.call('rbind',
    mclapply(accessions,
    function(acc) {
      acc.annos <- retrieve.annotations(uniprotkb.url(acc),...)
      matrix(acc.annos, nrow=1, dimnames=list(c(acc),names(acc.annos)))
    },
    mc.preschedule=F, mc.cores=50)
  )
}

retrieve.annotations.parallel <- function(accessions, ...) {
  # Method invokes the function retrieve.annotations for each provided
  # accession in parallel. Resulting lists of annotated domain ids of the
  # various types are merged into a matrix. The annotated domain types
  # will be the matrix's column names and row names will be the argument
  # 'accessions'. 
  # NOTE: This method returns the transposed matrix as generated by function
  # 'retrieve.annotations.parallel'.
  #
  # Args:
  #  accessions : Uniprot accessions to retrieve anntotated domains for.
  #  ...        : Additional provided arguments are passed on to the function
  #               'retrieve.annotations' and can be used to narrow the returned
  #               matrix's rows to less than the default domain types 'InterPro', 'GO'
  #               and 'Pfam'. 
  #
  # Returns: A matric with column names the function annotation types and
  # row names the accessions they were retrieved for from Uniprot.
  #   
  do.call('cbind',
    mclapply(accessions,
    function(acc) {
      acc.annos <- retrieve.annotations(uniprotkb.url(acc),...)
      matrix(acc.annos, nrow=length(acc.annos),
        dimnames=list(names(acc.annos),c(acc)))
    },
    mc.preschedule=F, mc.cores=50)
  )
}

uniq.annotations <- function( annotation.matrix, type, exclude.NAs=FALSE ) {
  # Looks up all pairwise distinct annotations of argument type. NAs can be
  # excluded.
  #
  # Args:
  #  annotation.matrix : The matrix of protein annotations as returned by
  #                      function 'retrieveAnnotationsBiomart'.
  #  type              : The row name of 'annotation.matrix', i.e. 'GO' or
  #                      'InterPro'.
  #  exclude.NAs       : Switch indicating wether to include NA values in the
  #                      result.
  #
  # Returns: an alphabetically sorted vector of all pairwise distinct
  # annotations.
  #   
  ua <- sort(
    unique(do.call('c', (annotation.matrix[type,]))),
    na.last=F
  )
  if ( exclude.NAs ) {
    ua[ ! is.na(ua[]) ]
  } else {
    ua 
  }
}

retrieveAnnotationsBiomart <- function( accs,
    uni.mart=useDataset("uniprot",mart=useMart("unimart"))
  ) {
  # Uses library biomaRt to retrieve InterPro and Gene Ontology annotations for
  # the Proteins referenced by their accessions in argument 'accs'. Results are
  # returned as a matrix where the rows are the Protein accessions and the
  # columns 'InterPro' and 'GO'. NOTE: This function cannot retrieve Pfam
  # annotations.
  #
  # Args:
  #  accs       : The accessions of the proteins to retrieve annotations for.
  #  uni.mart   : The biomaRt mart object to use.
  #
  # Returns: A matrix with all InterPro and GO annotations for the query
  # proteins. Columns are the protein accessions and rows 'InterPro' and 'GO'.
  #   
  annos <- getBM( c("accession", "interpro_id", "go_id"),
    filters=c("accession"), values=accs, mart=uni.mart )
  do.call( 'cbind',
    lapply( accs, function(a) {
      matrix(
        list( 
          'InterPro'=unique( annos[ annos["accession"] == a, "interpro_id" ] ),
          'GO'=unique( annos[ annos["accession"] == a, "go_id" ] )
        ),
        nrow=2, ncol=1,
        dimnames=list( c('InterPro', 'GO'), a )
      )
    })
  )
}

downloadUniprotDocuments <- function( uniprot.uris ) {
  # Downloads the documents from the RESTful Uniprot web service.
  #
  # Args:
  #  uniprot.uris : A vector or list of uniprot URLs
  #
  # Returns: Returns a named character vector of the downloaded XML documents.
  # Names are the 'uniprot.uris'.
  getURL( uniprot.uris )
}

retrieveSequence <- function( doc ) {
  # Parses the XML Uniprot document 'doc' and returns the content of the
  # contained amino acid sequence.
  #
  # Args:
  #  doc : The document downloaded from Uniprot using the URL as generated by
  #        function 'uniprotkb.url'.
  #
  # Returns: The content of the contained '<sequence>...</sequence>' tag.
  #   
  ns <- c(xmlns="http://uniprot.org/uniprot");
  gsub("\\s", "",
    xmlValue(
      getNodeSet(
        xmlInternalTreeParse(doc),
        "//xmlns:entry/xmlns:sequence",
        ns
      )[[1]]
    )
  )
}

retrieveSequences <- function( downloaded.uniprot.docs,
  max.retries=10, noverbose=F ) {
  # Parses each downloaded argument Uniprot document and extracts the content
  # of the '<sequence>' tag. If an error occurs doing so, re-tries downloading
  # and parsing the document, after sleeping a random amount of time out of
  # 1:90 seconds.
  #
  # Args:
  #  downloaded.uniprot.docs : The documents downloaded from Uniprot's RESTful
  #                            web service. 
  #  max.retries : The maximum number of times another download is attempted.
  #  noverbose : switch indicating wether to print out errors
  #
  # Returns: A named vector of extracted sequences or error messages.
  #   
  seqs <- sapply( downloaded.uniprot.docs, function( doc ) {
      try( retrieveSequence( doc ), silent=noverbose )
    })
  err.indxs <- grepl("^Error", seqs[], perl=T) 
  err.uris <- names( seqs[ err.indxs ] )
  if ( length(err.uris) > 0 && max.retries > 0 ) {
    Sys.sleep( sample(1:90, 1) )
    print( paste( "Retry number", as.character( 11 - max.retries) ) )
    seqs <<- c(
      seqs[ ! err.indxs ],
      retrieveSequences( downloadUniprotDocuments( err.uris ),
        (max.retries - 1) )
    )
  }
  # Return
  seqs
}

sharedFunction <- function( annotation.matrix,
  accessions=colnames(annotation.matrix), annotation.type='GO' ) {
  # Constructs a Boolean matrix with column names as in the argument
  # 'annotation.matrix' columns. Rows are the argument accessions. Each matrix
  # entry is TRUE if and only if the two corresponding proteins share at least
  # a single annotation. 
  #
  # Args:
  #  annotation.matrix : Matrix holding different function annotation for its
  #                      column proteins
  #  accessions : The accessions to compute the Boolean entries for, default
  #               all proteins in annotation.matrix
  #  annotation.type : The type of functional annotation to use, default 'GO'
  #
  # Returns: Boolean matrix with rows as in argument 'accessions' and columns
  # the same as in argument 'annotation.matrix'.
  #   
  do.call( 'cbind',
    setNames(
      mclapply( colnames(annotation.matrix), function( a ) {
          sapply( accessions, function( b ) {
              length(
                intersect(
                  annotation.matrix[[ annotation.type, a ]],
                  annotation.matrix[[ annotation.type, b ]]
                )
              ) > 0
          } )
      }, mc.cores=detectCores(), mc.preschedule=T ),
      colnames(annotation.matrix)
    )
  )
}

sharedAnnotation <- function( annotation.matrix,
  annotation, annotation.type='GO' ) {
  # Filters argument 'annotation.matrix' where cells in row 'annotation.type'
  # include the argument 'annotation'. 
  #
  # Args:
  #  annotation.matrix : The matrix of functional annotations as returned by
  #                      i.e. 'retrieveAnnotationsBiomart'.
  #  annotation        : The annotation to filter for, i.e. "GO:0005634"
  #  annotation.type   : The row of the annotation.matrix to check entries,
  #                      default 'GO'.
  #
  # Returns: Returns matching sub-matrix.
  #   
  annotation.matrix[ ,
    mapply(
      function(x){ any( x == annotation & ! is.na(x) ) },
      annotation.matrix[ annotation.type, ]
    ),
    drop=F
  ]
}

intersectAnnotations <- function( annotation.matrix, acc.a, acc.b, annotation.type="GO" ) {
  # Intersects the annotations of protein 'acc.a' with protein 'acc.b' using
  # the argument 'annotation.type'.
  #
  # Args:
  #  annotation.matrix : The annotations as returned i.e. by
  #                      'retrieveAnnotationsBiomart'
  #  acc.a : Accession of first protein 
  #  acc.b : Accession of second protein 
  #
  # Returns: The set intersection of the two proteins' annotation sets.
  #   
  intersect( annotation.matrix[[ annotation.type, acc.a ]],
    annotation.matrix[[ annotation.type, acc.b ]]
  )
}

shareAnnotation <- function( annotation, annotation.matrix, acc.a, acc.b,
  annotation.type="GO" ) {
  # Looks up the annotations of both arguments 'acc.a' and 'acc.b' and checks
  # if both have argument 'annotation' in their 'annotation.type' set. 
  #
  # Args:
  #  annotation : The GO term, InterPro ID, or Pfam ID to look up.
  #  annotation.matrix : The annotations as returned i.e. by
  #                      'retrieveAnnotationsBiomart'
  #  acc.a : Accession of first protein 
  #  acc.b : Accession of second protein 
  #
  # Returns: TRUE if and only if, both proteins share the argument
  # 'annotation', FALSE otherwise.
  #   
  annotation %in% intersectAnnotations( annotation.matrix, acc.a, acc.b,
    annotation.type
  )
}

extractExperimentallyVerifiedGoAnnos <- function( doc, xpath.prefix='//' ) {
  # Uses XPath to extract those GO annotations that are experimentally
  # verified. Note, that warnings generated by calls to the XML library are
  # suppressed to not confuse the user, when no experimentally verified GO
  # annotations could be found.
  #
  # Args:
  #  doc          : A XML tag of type entry as returned i.e. by function
  #                 'getEntries'
  #  xpath.prefix : Define the scope in which to apply the XPath search. '//'
  #                 means whole document, './' means children of the current
  #                 node.
  #
  # Returns: A 1*1 matrix containing a character vector of the extracted
  # experimentally verified GO annotations. Row name is 'GO' and column name is
  # the proteins FIRST accession as appearing in the XML document. Returns
  # NULL, if no experimentally verified Go annotations can be found.
  #   
  block <- function() {
    ns <- c( xmlns="http://uniprot.org/uniprot" )
    ndst <- suppressWarnings(
      getNodeSet( doc,
        paste(
          xpath.prefix,
          "xmlns:dbReference[@type='GO']//xmlns:property[@type='evidence' and ( contains(@value, 'EXP') or contains(@value, 'IDA') or contains(@value, 'IPI') or contains(@value, 'IMP') or contains(@value, 'IGI') or contains(@value, 'IEP') ) ]/..",
          sep=""
        ),
        namespaces=ns
      )
    )
    acc <- suppressWarnings(
      xpathApply( doc, paste( xpath.prefix, "xmlns:accession", sep="" ),
        xmlValue, namespaces=ns )[[1]]
    )
    if ( ! is.null( ndst ) && length( ndst ) > 0 ) {
      mtrx <- matrix( list(), ncol=1, nrow=1, dimnames=list( 'GO', acc ) )
      mtrx[[ 1, 1 ]] <- vapply( ndst, xmlGetAttr, vector( mode='character', length=1 ), 'id' )
      mtrx
    } else
      NULL
  }
  tryCatch( block(), error=function( err ) {
    warning( err, " caused by document ", doc )
  })
}

getEntries <- function( uniprot.xml, uniprot.error.msg.regex='^ERROR' ) {
  # Uniprot's dbfetch can be asked to return several entry tags in the same XML
  # document. This function uses XPath queries to extract all complete uniprot
  # tags. 
  #
  # Args:
  #  uniprot.xml             : The result of a web fetch to Uniprot i.e. using
  #                            getURL.
  #  uniprot.error.msg.regex : A regular expression to avoid parsing an error
  #                            returned from Uniprot.
  #
  # Returns: A list of extracted uniprot-entry-tags as returned by function
  # 'getNodeSet'. 
  #   
  if ( ! is.null( uniprot.xml ) && '' != uniprot.xml &&
    ! grepl( uniprot.error.msg.regex, uniprot.xml )
  ) {
    ns <- c( xmlns="http://uniprot.org/uniprot" )
    getNodeSet( 
      xmlInternalTreeParse( uniprot.xml ), 
      "//xmlns:entry", namespaces=ns
    )
  } else {
    NULL
  }
}

retrieveExperimentallyVerifiedGOAnnotations <- function( uniprot.accessions,
  uniprot.webfetch.max.ids=200 ) {
  # Downloads and parses XML documents from Uniprot for each accession in
  # argument. Extracts all experimentally verified GO annotations.
  #
  # Args:
  #  uniprot.accessions       : A character vector of Uniprot accessions.
  #  uniprot.webfetch.max.ids : The current maximum number of IDs in a batch
  #                             fetch allowed by the Uniprot webfetch service.
  #
  # Returns: A matrix with row 'GO' and one column for each Uniprot accession.
  # Each cell is either NULL or a character vector holding all experimentally
  # verified GO annotations. NULL annotations are excluded, so the returned
  # matrix can be of zero columns and a single row.
  #   
  if ( length( uniprot.accessions ) > uniprot.webfetch.max.ids ) {
    # Recursive fetch of uniprot.webfetch.max.ids sized batches:
    cbind( 
      retrieveExperimentallyVerifiedGOAnnotations( 
        uniprot.accessions[ 1:uniprot.webfetch.max.ids ] ),
      retrieveExperimentallyVerifiedGOAnnotations(
        uniprot.accessions[
          ( uniprot.webfetch.max.ids + 1 ):length(uniprot.accessions)
        ]
      )
    )
  } else {
    # Fetch max uniprot.webfetch.max.ids in a single batch:
    fetch.url <- uniprotkb.url( paste( uniprot.accessions, collapse=",", sep="" ) )
    uniprot.entries <- getEntries( getURL( fetch.url ) )  
    if ( ! is.null(uniprot.entries) && length( uniprot.entries ) > 0 ) {
      annos <- do.call( 'cbind',
        lapply( uniprot.entries , function( d ) {
          extractExperimentallyVerifiedGoAnnos( d, xpath.prefix='./' )
        })
      )
      # Exclude NULL columns:
      annos[ , as.character( annos[ 'GO', ] ) != 'NULL' , drop=F ]
    }
  }
}
